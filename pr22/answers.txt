Ответы на вопросы для самоконтроля

1. В чем преимущества использования миграций для управления схемой БД?

Преимущества миграций:
- Версионность: возможность отслеживать историю изменений схемы БД
- Воспроизводимость: одинаковое состояние БД на всех окружениях
- Откат изменений: возможность вернуться к предыдущей версии схемы
- Коллаборация: упрощение работы команды над одной БД
- Автоматизация: интеграция в процессы разработки и развертывания
- Документирование: миграции служат документацией изменений БД

2. Какие типы связей между таблицами вы знаете и как их организовать?

Основные типы связей:
- Один-к-одному (1:1): одна запись в таблице A связана с одной записью в таблице B
- Один-ко-многим (1:N): одна запись в таблице A связана с несколькими записями в таблице B
- Многие-ко-многим (N:M): несколько записей в таблице A связаны с несколькими записями в таблице B

Организация связей:
- Внешние ключи (FOREIGN KEY) для связей 1:1 и 1:N
- Промежуточная таблица для связи N:M
- Индексы для оптимизации JOIN-запросов
- Ограничения целостности (CASCADE, SET NULL, RESTRICT)

3. Что такое ORM и каковы его преимущества перед нативными SQL-запросами?

ORM (Object-Relational Mapping) - технология преобразования данных между реляционной БД и объектной моделью.

Преимущества ORM:
- Абстракция БД: независимость от конкретной СУБД
- Безопасность: защита от SQL-инъекций
- Продуктивность: меньше шаблонного кода
- Type Safety: проверка типов в TypeScript
- Миграции: упрощенное управление схемой БД
- Валидация: встроенные механизмы проверки данных

Недостатки:
- Сложные запросы могут быть менее эффективными
- Дополнительный слой абстракции
- Кривая обучения

4. Как организовать пагинацию на уровне базы данных?

Методы пагинации:
- LIMIT/OFFSET: SELECT * FROM table LIMIT 10 OFFSET 20
- Keyset Pagination: SELECT * FROM table WHERE id > last_id LIMIT 10
- Нумерованная пагинация с подсчетом общего количества записей

В проекте использован подход:
const offset = (page - 1) * limit;
const books = await db('books').limit(limit).offset(offset);
const total = await db('books').count('* as count').first();

5. Что такое транзакции и когда их следует использовать?

Транзакция - группа операций, выполняемых атомарно (принцип "все или ничего").

Когда использовать:
- Финансовые операции (переводы денег)
- Сложные обновления нескольких таблиц
- Обеспечение целостности данных
- Операции, где критична согласованность данных
- Откат изменений при ошибках

Пример:
await db.transaction(async trx => {
  await trx('accounts').where('id', 1).decrement('balance', 100);
  await trx('accounts').where('id', 2).increment('balance', 100);
});

6. Какие методы оптимизации запросов к базе данных вы знаете?

Методы оптимизации:
- Индексы: для полей в WHERE, JOIN, ORDER BY
- Нормализация: устранение избыточности данных
- Денормализация: для часто читаемых данных
- Кэширование: Redis, Memcached для частых запросов
- Партиционирование: разделение больших таблиц
- EXPLAIN ANALYZE: анализ плана выполнения запросов
- Оптимизация запросов: избегать SELECT *, использовать LIMIT
- Connection pooling: пул соединений для уменьшения накладных расходов

7. Как организовать обработку ошибок при работе с БД?

Подходы к обработке ошибок:
- Try/catch блоки вокруг асинхронных операций с БД
- Централизованный обработчик ошибок в Express
- Логирование ошибок для отладки
- Группировка ошибок по типам (валидация, не найдено, конфликт)
- Возврат понятных сообщений об ошибках клиенту
- Использование HTTP статус-кодов (400, 404, 500)
- Обработка специфичных ошибок БД (уникальность, внешние ключи)

8. В чем разница между внутренним и внешним соединением таблиц?

INNER JOIN: возвращает только совпадающие записи из обеих таблиц
Пример: SELECT * FROM books INNER JOIN authors ON books.author_id = authors.id;

LEFT JOIN: возвращает все записи из левой таблицы и совпадающие из правой
Пример: SELECT * FROM books LEFT JOIN authors ON books.author_id = authors.id;

RIGHT JOIN: возвращает все записи из правой таблицы и совпадающие из левой
FULL JOIN: возвращает все записи из обеих таблиц

В проекте использованы LEFT JOIN для получения связанных данных:
db('books')
  .leftJoin('authors', 'books.author_id', 'authors.id')
  .leftJoin('categories', 'books.category_id', 'categories.id')